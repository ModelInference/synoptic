package synoptic.tests.integration;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.Test;

import synoptic.invariants.BinaryInvariant;
import synoptic.invariants.ITemporalInvariant;
import synoptic.invariants.RelationPath;
import synoptic.invariants.fsmcheck.FsmModelChecker;
import synoptic.invariants.ltlchecker.GraphLTLChecker;
import synoptic.main.Main;
import synoptic.main.ParseException;
import synoptic.main.TraceParser;
import synoptic.model.interfaces.IGraph;
import synoptic.model.interfaces.INode;
import synoptic.util.InternalSynopticException;

/**
 * Tests to compare the LTL checker against the FSM checker.
 * 
 * @author ivan
 */
public class CompareLTLandFSMCheckers {

    /**
     * We compare the two model checkers by parsing events from the same log
     * (using this parser) and then model checking the resulting graphs for
     * invariants using both types of model checkers.
     */
    TraceParser parser;

    @Before
    public void setUp() throws ParseException, InternalSynopticException {
        Main.recoverFromParseErrors = false;
        Main.ignoreNonMatchingLines = false;
        Main.debugParse = false;
        parser = new TraceParser();
        parser.addRegex("^(?<TYPE>)$");
        parser.addSeparator("^--$");
    }

    /**
     * Compares counter-example violations paths generated by the the two model
     * checkers.
     * 
     * @param <T>
     *            types of nodes in the graph
     * @param invs
     *            the invariants for which counter-examples should be produced
     * @param graph
     *            the graph over which counter-examples should be produced
     */
    private <T extends INode<T>> void compareViolations(
            List<ITemporalInvariant> invs, IGraph<T> graph) {
        GraphLTLChecker<T> ch = new GraphLTLChecker<T>();

        List<BinaryInvariant> bitSetInput = new ArrayList<BinaryInvariant>();
        for (ITemporalInvariant tinv : invs) {
            bitSetInput.add((BinaryInvariant) tinv);
        }
        List<BinaryInvariant> violated = FsmModelChecker.runBitSetChecker(
                bitSetInput, graph);

        for (int i = 0; i < invs.size(); i++) {
            BinaryInvariant inv = (BinaryInvariant) invs.get(i);
            RelationPath<T> path = ch.getCounterExample(inv, graph);
            RelationPath<T> fsm_path = FsmModelChecker.getCounterExample(inv,
                    graph);

            assertTrue(fsm_path == null == (path == null));

            if (fsm_path != null) {
                // logger.info("both found " + inv);
                // logger.info("fsm_path.size = " + fsm_path.path.size());
                // logger.info("path.size = " + path.path.size());
                assertTrue(fsm_path.path.size() == path.path.size());
                assertTrue(path.path.get(path.path.size() - 1).isTerminal());
            }
            assertTrue(path != null == violated.contains(inv));
        }
    }

    /**
	 *
	 */
    @Test
    public void testSameInvariants() {
        fail("todo");
    }

}
