%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Distributed systems are often difficult to debug and to
understand. This difficulty can be usually ascribed to the complex
behavior of the nodes comprising the system. For instance, nodes may
execute intertwined and difficult to follow distributed protocols.
Another difficulty is the distributed nature of state. No node can
observe all the system state, and due to asynchrony in the networking
environment, observations of remote state are stale unless protocols
with significant overhead are used.

%act concurrently with one another and may participate in multiple
%protocols simultaneously.

Developers who design and implement distributed systems often analyze
system behavior by collecting execution traces. However, even a small
system may generate thousands of messages -- just a few nodes running
a standard distributed protocol such as two-phase
commit~\cite{TwoPhaseCommit}, or Paxos~\cite{Paxos} can generate this
many messages over just a few minutes of execution time. Manual
inspection of such traces scales poorly and by skimming over the
trace, a developer may easily miss an important system behavior. It is
therefore challenging to understand the behavior of a system from
collected traces without tools to support this process. In this paper
we describe the design and implementation of \emph{Synoptic} -- a tool
to generate a Finite State Machine (FSM) representation of distributed
system executions. Synoptic analyzes the network-level traces
generated by nodes in a distributed system and can help the developer
to understand actual system behavior and help to uncover potential
system correctness and performance issues.

We approach the problem of understanding the system as a summarization
and a data reduction challenge. A Synoptic-derived representation is
not a specification for a system. But the representation is a compact,
and most importantly useful, summary of the observed system behaviors.
Synoptic describes the behavior of a distributed system while
preserving certain temporal invariants mined from the the ordering of
messages in the trace.

% Additionally, we distinguish our problem from compression, which
% must retain \emph{all} information. Our representation, on the other
% hand, can trade-off information content for
% conciseness. Additionally, unlike compressed content, our
% representation is intended to be inspected by a human. For this
% reason, the \emph{form} of the representation is an important
% consideration.

As part of building Synoptic we developed a framework for searching
through the space of potential FSM representations of the initial
system trace. We develop two approaches to explore this space --
coarsening and refinement. Coarsening starts out with the concrete
trace and attempts to compact the representation at each step without
admitting a representation that may represent illegal
traces. Refinement is the reverse process, in which a representation
is expanded starting from a single state until it admits all the
observed system traces. To guide coarsening and refinement we develop
a decision engine and a set of policies relevant to our domain. Within
this framework we implement two concrete algorithms that repeatedly
apply one of the exploration strategies. Our coarsening algorithm,
\emph{GK-Tail}, is based on the algorithm developed by Lorenzoli,
et. al.~\cite{AGSBM} relying on the intuition that messages between
nodes may be considered as remote method invocations. Our refinement
algorithm, \emph{Bikon}, is a bisimulation-inspired algorithm.

% ~\footnote{Bikon = [Bi]simulation + Dai[kon]}

% We implement the framework and these two algorithms in a tool called
% \emph{Synoptic}.
We applied Synoptic to real and synthetic traces of distributed
systems. We evaluated the derived representations in a user study with
a distributed systems developer. In this study, the developer was
asked to talk through his understanding of the represented system
behavior. From this study we found that Synoptic's output matched the
mental model of the developer and that the developer was able to
remember specific corner-case design choices by studying the
representation.

In summary, the contributions of this paper are the following. We
develop a framework for searching through the space of potential FSM
representation of a distributed system trace. Within this framework we
implement two algorithms, and evaluate the resulting Synoptic tool on
a variety of distributed system traces and in the context of a user
study. This paper includes the representations found by both
algorithms for a number of popular distributed protocols and systems,
the results of our user study, and performance results for our
coarsening and refinement algorithms.

In the next section we motivate our work with an example that
illustrates how Synoptic may be used to understand a complex
distributed protocol. We then overview our assumptions and the design
of our framework in sections~\ref{sec:assumptions} and
~\ref{sec:design}. We then describe the interface to our decision
engine and some of the policies it implements in
section~\ref{sec:decision_engine}.  We follow with
section~\ref{sec:gk_tail} and~\ref{sec:bisimulation} in which we
describe our two algorithms -- the adapted GK-Tail and Bikon. Then, we
present an evaluation of Synoptic in section~\ref{sec:evaluation}. We
finish with a discussion (section~\ref{sec:discussion}), an overview
of the related work (section~\ref{sec:related}), and conclude with
section~\ref{sec:conclusion}.
