%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
\label{sec:related}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{GK-Tail.} The work by Lorenzoli, et. al.~\cite{AGSBM} is
most closely related to ours, and inspired our use of the GK-Tail
algorithm. In this work, multiple interaction traces are used to
automatically generate an Extended Finite State Machine (EFSM). Each
trace consists of a sequence of method invocations annotated with
values for parameters and variables, and is generated by a single
execution run of the program being analyzed.  The resulting transition
arcs of the EFSM are annotated with the relevant constraints on the
data to transition from one state to the next state, providing a
behavioral view of the program that includes how the input data
affects the behavior. This algorithm is beneficial in understanding
program behavior and in generating tests with better coverage. Our
work generalizes GK-Tail to consider multiple k-future equivalent
nodes, adapts the algorithm to the domain of distributed systems, and
further modifies it to respect temporal constraints between nodes.

Another closely related work by Krka et. al.~\cite{Krka10icse-nier}
addresses FSA generation for objects, i.e. a state based representation
of legal method call sequences. The approach first generates a
invariant graph based on inferred invariants from Daikon. Then the
method call sequences are compressed using $kTail$, but merges that
would lead to invalid call sequences according to the first FSA are
restricted. The result is less likely to contain invalid traces.

A third use of $kTail$ is found in a paper by Lo
et. al.~\cite{ASBMI}. In this work as the execution traces are mined
for temporal properties which are then used to steer the $kTail$
algorithm to ensure that a given merge will not produce a graph that
violates any of the temporal constraints. The paper focuses on the
methods used to mine temporal properties and on the complexity of
enforcing those constraints during the $kTail$ algorithm. It shows
that $kTail$ with steering produces graphs with much higher precision.
This methodology is similar to the ``steering'' of GK-Tail provided by
the decision engine in Synoptic. The paper's main focus is the
difference between $kTail$ with steering and without steering, while
Synoptic incorporates these methods into a more comprehensive
distributed systems analysis tool.

% Their model captures information regarding both the temporal state
% graph structure of the program as well as the data constraints for
% each transition edge in this graph. To generate this EFSM, multiple
% traces are used where each trace consists of a sequence of method
% invocations annotated with values for parameters and variables. The
% resulting EFSM is beneficial in understanding program behavior and in
% generating tests with better coverage.

\paragraph{Bisimulation.} Bisimulations are simulation relations that
provide a strong notion of similarity for relational structures. They
emerged in different fields~\cite{OriginsBisim}, and their key
property is preserving certain properties of the relational structure,
for example, two strongly bisimilar transition systems are guaranteed
to satisfy the same set of LTL formulas. Building on this property, an
important application in model checking is model
minimization~\cite{BisimMin}. Our Bikon algorithm is a modification of
a partition refinement algorithm~\cite{PartRefine}. Bikon uses
invariants to determine which state to split next, and we stop
splitting much earlier (once all invariants are satisfied), which
results in a coarser representation.

% \paragraph{Daikon.} The Daikon~\cite{Daikon} tool detects likely
% program invariants from observed program executions. During analysis
% of the execution traces, at marked program points Daikon instantiates
% a set of template invariants and tracks those invariants that hold
% true for the observed sequence of variable values. We plan to employ
% this technique to relate data fields of messages, and to find data
% invariants that hold between messages.

%   Dynamically inferred program
% invariants have also been used by DIDUCE~\cite{DIDUCE} to report
% invariant violations that might indicate software bugs. DIDUCE is an
% online tool that can be run to learn program invariants, as well as to
% check previously learned invariants. To infer invariants, DIDUCE
% instruments Java programs to output value of tracked expressions and
% uses a relaxation method by which strict invariants that match initial
% values are relaxed over time to accommodate new information.

% TODO: How is DIDUCE different from Daikon? Why did we not use
% DIDUCE? (note: both daikon and diduce are online)

\paragraph{Debugging distributed systems.} Distributed systems are
notoriously difficult to get right. Recent efforts by the systems
community target bug finding in distributed systems with model
checking. MODIST~\cite{MODIST} explores the inter-leavings of
concurrent events in an unmodified distributed system, thereby model
checking the live system. CrystallBall~\cite{CrystallBall} explores
the state space of an actively executing distributed system, and when
inconsistencies in possible future states are found, CrystallBall can
be used to steer the distributed system away from buggy states.
Magpie~\cite{Magpie} and X-Trace~\cite{XTrace} operate a fine
granularity of request processing in a distributed system. Magpie is
primarily used for performance debugging and X-Trace is used to
understand pipelined request processing. All these tools, however, do
not target the extraction of system properties that may be used to
understand the behavior of the system they check.

Property representations produced by Synoptic may be leveraged
by these tools to guide model checking, and Synoptic may use these
tools to target system execution towards states for which Synoptic
lacks information to derive a concise representation.

\paragraph{Inferring temporal properties of programs.}
Perracotta~\cite{Perracotta04_Main} is a tool to mine temporal
properties from program event traces. It has been used to study traces
of function calls for program
evolution~\cite{Perracotta04_ProgramEvolution}. It has also been made
scalable and robust to analysis of imprecise event traces to
understand behavior and uncover bugs in very large code-bases such as
the Windows Kernel and the JBoss application
server~\cite{Perracotta06_ImperfectTraces}. Perracotta first
instruments the program to output event information -- all prior work
uses method entrance and exit points. Second, the instrumented program
is run -- Perracotta relies on extensive test suites and random
exploration of method calls to generate a broad range of event
traces. Finally, the generated traces are used to infer program
properties. The system generates candidate temporal patterns and then
attempts to gain evidence that indicate the pattern holds by scanning
through the trace. Patterns are expressed in terms of quantified
regular expressions which are similar to regular expressions. The
system uses a partial order hierarchy of properties that are built on
the response pattern -- the simple cause effect relationship between
some two events.

Unlike Synoptic, Perracotta considers a totally ordered trace of
events and does not consider properties that might be of interest in
the domain of distributed systems. For instance, events may be
concurrent and cannot be ordered with respect to one
another. Additionally, Perracotta does not make use of any
relationships between event data (e.g. method arguments/message
payload).

\paragraph{Hidden Markov Models.} A classic approach to modeling a
system with unobserved state but with observations that may imply
certain system state and state transitions are Hidden Markov Models
(HMMs). The HMM model is powerful but it relies on knowing the set of
states, as well as the transition and emission probabilities for
transitioning between hidden states and emitting an observation in a
state respectively. In our setting, the system state is not observable
so the HMM model is applicable. However, from message traces alone it
is not even clear what is the right number of system states to use for
the HMM model. As well, the transition and emission probabilities are
not known. Using HMMs in our setting is therefore impractical because
of the large number of inputs that must be additionally supplied by
the user.

