%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}
\label{sec:discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% gain confidence in their system with testing and by analyzing traces
% of executions. 

% Testing, however, can be used to check For a large system, however,
% testing is not particularly useful for revealing overall system
% behavior. adhering to strict software engineering principles and
% methodologies such as test-driven development, and by amassing
% sufficient experimental evidence (e.g. message and node state traces)
% to indicate that the system operates without faults. Both of these
% methods are insufficient for constructing robust complex distributed
% systems and are problematic for two reasons. First, it is typically
% impossible to explore all states of a complex distributed
% system. Therefore model checking, and testing are only practical for
% checking correctness of a subset of system modules in a simple
% setting.

\textbf{Partitioning Strategies.} Alternative partitioning strategies
may yield different information about the trace. This is probably the
most complicated task the user faces when using Synoptic. As an
example of an alternative strategy consider partitioning messages
based on the tuple of source and destination address pairs. This will
produce representations that capture interactions between some two
nodes in the system. We hope to explore such alternative strategies in
our future work.

%  depending on the context. For example, let
% the ``type'' of a message refer to the message signature defined by
% all the fields in the message. Then we can map the tuple $\langle$
% type, src, dest $\rangle$ to a single transition. In other words,
% instead of grouping messages between nodes, we can group them by src
% and dest pairs. We also augmented the fields of the message a
% timestamp, and hope to include latency values. We can use this
% augmented set of fields for a different partitioning strategy

\textbf{Message Capture.} The protobuf library mentioned in
section~\ref{sec:evaluation} diminishes the amount of work necessary
to capture messages generated by a distributed system. However, there
are other methods of achieving the same result. For example, all
traffic on a local machine could be sniffed (e.g. using
\texttt{tcpdump}), or the system could be modified to use a custom
network library that logs all messages sent and received to persistent
storage. However, in the case of lower-level capture methods such as
tcpdump, more interpretation work must be performed to tease out
message fields relevant to the analysis.

% It may be interesting to investigate the difference between a product
% of the local models generated from traces at each node, versus one
% that is generated from a global trace. The analogy of this is given a
% brief mention by Lorenzoli, et. al. Specifically, they consider a
% multi-threaded environment and conclude that their approach may be
% applied to each thread individually, or to a global trace with
% inter-leavings as they occur during execution. This is a clear analog
% to the distributed systems case with one important exception -
% simultaneous events are now possible, and arbitrarily ordering them
% may introduce bias into the inference. It might therefore be necessary
% to extend the representation to capture concurrency.

\textbf{Alternative splitting policies.} Synoptic uses temporal
invariants on messages ordering to validate intermediate FSM
representations. However, other types of invariants could be leveraged
to guide the splitting decision of the Bikon algorithm. Structural
invariants offer an alternative. For instance, Daikon~\cite{Daikon}
can be used to find a sensible splitting of a set of messages
according to the data-fields associated with them. A split could be
evaluated by cross-validating the messages from one candidate
partition against the invariants from the other candidate partition,
and vice versa. The more messages that do not satisfy the invariants,
the better the split. Message fields over which structural invariants
should be generated could be specified within the protobuf format.

\textbf{Statistical methods.} It may be possible to improve our
framework with a suite of statistical methods. For example, it might
be necessary to ignore parts of the trace to come up with a concise
representation. This may correspond well to accounting for failure or
other unexpected events in the representation of the system. It is
unclear, however, what specific statistical models or machine learning
approaches are best to use since prior work on detecting such events
and partitioning traces by protocol indicates that this is a
challenging problem~\cite{Constellation}.

% might be part of our investigation. This will be approached as
% necessary -- when we scale to larger and more complex distributed
% systems we may find empirically that we cannot generate concise and
% useful models if we include all of the data in the analysis.

% \textbf{In the graph in which transitions represent messages, the
%   transitions may be annoted with the minimum and the maximum number
%   of messages that were observed to have taken the transition.}

\textbf{Further applications.} To evaluate the system in~\cite{AGSBM},
the authors use a test coverage metric. By ensuring that the set of
tests covers every transition arc in the FSM representation, the tests
can be considered to have a high degree of coverage. Our work may also
be evaluated using this metric. Specifically, if we are able to
trigger events in the system being studied, then we can drive
execution towards those transitions and states that were observed
infrequently.



