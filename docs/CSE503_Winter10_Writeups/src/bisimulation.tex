\newtheorem*{definition}{Definition}
\newcommand{\goesto}[1]{\ensuremath{\stackrel{#1}{\rightarrow}}}
\newcommand{\Act}{\ensuremath{A}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Bikon Algorithm}
\label{sec:bisimulation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We modified a partition refinement algorithm~\cite{PartRefine} to
build a bisimulation-inspired minimization that we call \emph{Bikon}.
This algorithm is novel because of a key property -- the algorithm
creates FSMs that preserve some temporal properties of messages --
e.g. certain message orderings.

% In addition, we use Daikon~\cite{Daikon} to guide partition
% refinement towards representations that group together structurally
% interesting messages. In particular, we apply Daikon when temporal
% properties are no longer sufficient to discriminate bisimulation
% states.

We interpret messages as states as described earlier. In the beginning, we partition
the graph by the data fields, i.e. we merge all messages with certain data-fields into one state.
We assume there is routine \texttt{partition} available for this purpose.

We then refine the graph until the \textit{checkGraphValidity} call to
the decision engine returns true. If \textit{checkGraphValidity} returns false, we
let the decision engine choose a predicate $p$ and a state
$\Delta$ to split according to the predicate. After adding two new states 
$\Delta_1,\Delta_2$, we have to update the edges in the graph. 
For this we use existential abstraction, i.e. we insert edges between states if 
two messages from the states are in the corresponding relation.

\begin{align*}
\textup{ex-abs}(V)~=~&\{(s_1,s_2,r)\in{V\times{V}\times{R}}~\\
&|~\exists{m_1}\in{s_1}\exists{m_2}\in{s_2}:~m_1\,r\, m_2\}
\end{align*}

The pseudo-code for Bikon is shown in Figure~\ref{fig:bikon_alg}.

%  in Figure \ref{figure:bikon-pseudo}

%Let $(S,A,\goesto{})$ be a transition system. Let
%\begin{align*}
%\textup{Bikon}(S,A,\goesto{})~=&~(S,A,\goesto{})&&\textup{DE.checkGraphValidity(S,A,\goesto{})}\\
%\textup{Bikon}(S,A,\goesto{})~=&~\textup{let}(a,\Delta)=\textup{DE.chooseSplit}(S,A,\goesto{})\\

%&~\textup{in Bikon}(S\cup\{\Delta',\Delta''\}-\Delta,A,\goesto{})
%\end{align*}
%\begin{itemize}
%\item $S/_{\approx_{0}}=\{S\}$
%\item $S/_{\approx_{n+1}}=S/_{\approx_{n}}\cup\{\Delta',\Delta''\}-\{\Delta\}$ with $\Delta\in{S}/_{\approx_{n}}$ 
%\\such that there is $a\in\Act$ with
%\begin{enumerate}[(a)]
%\item $\Delta'$=$\{s\in\Delta~|~ps\}$
%\item $\Delta''$=$\{s\in\Delta~|~\neg{p}s\}$
%\end{enumerate}
%\end{itemize}
%Then  $\stackrel{\rho}{\approx}=\bigcap_{n\geq{0}}\approx_n$ is the
%$\rho$-condensation of $(S,A,\goesto{})$.

\begin{figure}[!t]

\begin{lstlisting}[mathescape=true,morekeywords={Input,Output}]
Input: $(V,E)$
$(V,E)$ := partition$(V,E)$
While not DE.checkGraphValidity($(V,E)$)
  Let ($p$, $\Delta$) = DE.getSplit($(V,E)$)
  Let $\Delta_1$ = $\{s\in\Delta~|~p s\}$
  Let $\Delta_2$ = $\{s\in\Delta~|~\neg p s\}$
  $V$ := $V\cup{\{\Delta_1,\Delta_2\}}-\{\Delta\}$
  $E$ := ex-abs($V$)
Output: $(V,E)$
\end{lstlisting}

\caption{The Bikon algorithm}
\label{fig:bikon_alg}

\end{figure}

% \textbf{(find a better name)} 


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \subsection{Using structural properties for arbitration}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

% The above algorithm captures temporal properties of a message trace.
% However, it does not in any way consider the structural properties of
% the messages. We use Daikon to arbitrate those cases where the relaxed
% bisimulation algorithm is unable to decide whether or not to split a
% node. In particular we use Daikon for those nodes that have reached
% equilibrium with respect to $\rho$.

% We consider the set of invariants that are associated with messages
% corresponding to two edges -- the edge that induces the split (i.e.
% which is present in only one of the partitions), and the same edge in
% the unpartitioned node. We consider the sub-trace of messages
% corresponding to the two types of messages (e.g. source and
% destination of each edge) and employ Daikon to generate a set of
% invariants for the two edges. We then compare the set of invariants
% and use a metric to decide which edge has more structural properties
% -- this is the edge we keep. As one metric, we can use the raw number
% of generated invariants.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \subsection{Limitations}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

% A problem with the algorithm above is that certain value of $\rho$ can
% trigger many split, which means that the granularity of the output
% graph cannot be adjusted continuously. Another issue with the
% algorithm is its non-determinism. There are situations in which two
% splits are possible, and pursuing either of the splits will make the
% other impossible afterwards. Both issues might indicate that there
% needs to be a more sophisticated mechanism to decide when to split
% partitions.



%\begin{definition}
%Let (S,E) be a graph. Let
%\begin{itemize}
%\item $\sim_{0}=S\times{S}$
%\item $s\sim_{n+1}t\textup{ for }n\geq{0}\textup{ if }$
%\begin{itemize}
%\item for all $s'\in{S}$ with $s\goesto{a}s'$ for some $a\in\Act$, there is $t'\in{S}$ such that $t\goesto{a}t'$ and %$s'\sim_n{t'}$
%\item the converse
%\end{itemize}
%\item $\sim_\omega=\bigcap_{n\geq{0}}\sim_n$
%\end{itemize}
%\end{definition}

%This definition coincides with bisimulation for finite transition systems. In order to relax the similarity requirements we insert %the following conditions:



%\begin{definition}
%A similarity relation on a graph $(S,E)$ is an equivalence relation $R$ on $S$ such that $(s, t)\in{}R$ implies
%for all $a\in\Act$ and all $C,C'\in{S/R}$
%\begin{align*}
%\frac{|\{s'\in{C}~|~\exists{s'}:~s\goesto{a}C'\}|}{|C|}\not\in\frac{1}{2}-k,\frac{1}{2}+k)
%\end{align*}
%\end{definition}

 

%This especially means that temporal order is respected by the minimization process.

%Consider, for example, the ping/pong/status interaction from section \ref{section:ping-pong-example}. For an observed %message trace, ping messages should evoke similar behaviors, since they are often followed by 



